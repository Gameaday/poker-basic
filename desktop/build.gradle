// Pokermon Desktop - Native Executable Builds
// Creates platform-specific native executables

plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'application'
}

// Application configuration for desktop
application {
    mainClass = 'com.pokermon.GameLauncher'
}

// Java compatibility
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

// Kotlin configuration
kotlin {
    jvmToolchain(17)
}

// Dynamic version from root project
version = rootProject.version
group = rootProject.group

// Dependencies - Use shared module
dependencies {
    implementation project(':shared')
    
    // Desktop-specific dependencies for native builds
    implementation "org.jetbrains.kotlin:kotlin-stdlib:${findProperty('kotlin.version') ?: '1.9.22'}"
    
    // For future native compilation support
    // implementation 'org.graalvm.nativeimage:svm:23.0.0' // Future: GraalVM Native Image
}

// Kotlin compilation options with production optimizations
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
    kotlinOptions {
        jvmTarget = '17'
        
        // Base compiler arguments
        def baseArgs = [
            '-Xjsr305=strict',
            '-opt-in=kotlin.ExperimentalStdlibApi'
        ]
        
        // Add production optimizations for non-development builds
        def isDevelopment = project.hasProperty('developmentBuild') && project.developmentBuild
        if (!isDevelopment) {
            baseArgs += [
                '-Xno-call-assertions',
                '-Xno-param-assertions',
                '-Xno-receiver-assertions',
                '-Xassertions=legacy'
            ]
        }
        
        freeCompilerArgs = baseArgs
    }
}

// Task to create Windows native executable using jpackage
task packagewindows {
    group = 'native'
    description = 'Package Windows native executable (.exe) using jpackage'
    
    doLast {
        println "=== Windows Native Build with jpackage ==="
        
        // Ensure shared JAR is built first
        if (!project(':shared').tasks.getByName('fatJar').state.executed) {
            project(':shared').tasks.getByName('fatJar').execute()
        }
        
        def buildDir = new File(project.buildDir, 'distributions')
        buildDir.mkdirs()
        
        def sharedLibsDir = new File(project(':shared').buildDir, 'libs')
        def sourceJar = sharedLibsDir.listFiles()
            ?.find { it.name.endsWith('-fat.jar') }
        
        if (!sourceJar || !sourceJar.exists()) {
            throw new GradleException("Could not find fat JAR in ${sharedLibsDir}")
        }
        
        // Check if jpackage is available
        try {
            def jpackageCheck = "jpackage --version".execute()
            jpackageCheck.waitFor()
            if (jpackageCheck.exitValue() != 0) {
                throw new Exception("jpackage command failed")
            }
        } catch (Exception e) {
            println "‚ö†Ô∏è  jpackage not available, creating launcher script instead"
            createWindowsLauncher(buildDir, sourceJar)
            return
        }
        
        // Create native Windows executable with jpackage
        def version = project.version
        def appName = "Pokermon"
        def tempDir = new File(buildDir, 'temp')
        tempDir.mkdirs()
        
        def jpackageCmd = [
            'jpackage',
            '--input', sharedLibsDir.absolutePath,
            '--main-jar', sourceJar.name,
            '--main-class', 'com.pokermon.GameLauncher',
            '--name', appName,
            '--app-version', version.toString(),
            '--dest', buildDir.absolutePath,
            '--temp', tempDir.absolutePath,
            '--type', 'exe',
            '--vendor', 'Pokermon',
            '--description', 'Pokermon - Pure Kotlin-Native Poker Game'
        ]
        
        // Add Windows-specific options only on Windows
        def osName = System.getProperty('os.name').toLowerCase()
        if (osName.contains('windows')) {
            jpackageCmd.add('--win-console')
        }
        
        println "Running: ${jpackageCmd.join(' ')}"
        def process = jpackageCmd.execute()
        process.waitFor()
        
        if (process.exitValue() == 0) {
            println "‚úÖ Native Windows executable created successfully!"
            def createdFiles = buildDir.listFiles()?.findAll { it.name.endsWith('.exe') || it.name.endsWith('.msi') }
            createdFiles?.each { file ->
                println "  üì¶ ${file.absolutePath}"
            }
        } else {
            println "‚ùå jpackage failed, creating launcher script instead"
            println "Error output: ${process.errorStream.text}"
            createWindowsLauncher(buildDir, sourceJar)
        }
    }
}

// Fallback method to create Windows launcher script
def createWindowsLauncher(buildDir, sourceJar) {
    def version = project.version
    def launcherScript = new File(buildDir, "Pokermon-${version}.bat")
    def jarCopy = new File(buildDir, "pokermon.jar")
    
    // Copy JAR to build directory
    jarCopy.bytes = sourceJar.bytes
    
    // Create batch launcher script
    launcherScript.text = """@echo off
echo Starting Pokermon v${version}...
cd /d "%~dp0"
if exist "pokermon.jar" (
    java -jar pokermon.jar %*
) else (
    echo Error: pokermon.jar not found in the same directory
    pause
)
"""
    
    println "‚úÖ Windows launcher created:"
    println "  üì¶ Launcher: ${launcherScript.absolutePath}"
    println "  üì¶ JAR: ${jarCopy.absolutePath}"
    println "  ‚ÑπÔ∏è  Run the .bat file to start Pokermon"
}

// Task to create Linux native executable using jpackage
task packagelinux {
    group = 'native'
    description = 'Package Linux native executable (.deb) using jpackage'
    
    doLast {
        println "=== Linux Native Build with jpackage ==="
        
        // Ensure shared JAR is built first
        if (!project(':shared').tasks.getByName('fatJar').state.executed) {
            project(':shared').tasks.getByName('fatJar').execute()
        }
        
        def buildDir = new File(project.buildDir, 'distributions')
        buildDir.mkdirs()
        
        def sharedLibsDir = new File(project(':shared').buildDir, 'libs')
        def sourceJar = sharedLibsDir.listFiles()
            ?.find { it.name.endsWith('-fat.jar') }
        
        if (!sourceJar || !sourceJar.exists()) {
            throw new GradleException("Could not find fat JAR in ${sharedLibsDir}")
        }
        
        // Check if jpackage is available
        try {
            def jpackageCheck = "jpackage --version".execute()
            jpackageCheck.waitFor()
            if (jpackageCheck.exitValue() != 0) {
                throw new Exception("jpackage command failed")
            }
        } catch (Exception e) {
            println "‚ö†Ô∏è  jpackage not available, creating launcher script instead"
            createLinuxLauncher(buildDir, sourceJar)
            return
        }
        
        // Create native Linux package with jpackage
        def version = project.version
        def appName = "pokermon"
        def tempDir = new File(buildDir, 'temp')
        tempDir.mkdirs()
        
        def jpackageCmd = [
            'jpackage',
            '--input', sharedLibsDir.absolutePath,
            '--main-jar', sourceJar.name,
            '--main-class', 'com.pokermon.GameLauncher',
            '--name', appName,
            '--app-version', version.toString(),
            '--dest', buildDir.absolutePath,
            '--temp', tempDir.absolutePath,
            '--type', 'deb',
            '--vendor', 'Pokermon',
            '--description', 'Pokermon - Pure Kotlin-Native Poker Game',
            '--linux-shortcut'
        ]
        
        println "Running: ${jpackageCmd.join(' ')}"
        def process = jpackageCmd.execute()
        process.waitFor()
        
        if (process.exitValue() == 0) {
            println "‚úÖ Native Linux package created successfully!"
            def createdFiles = buildDir.listFiles()?.findAll { it.name.endsWith('.deb') || it.name.endsWith('.rpm') }
            createdFiles?.each { file ->
                println "  üì¶ ${file.absolutePath}"
            }
        } else {
            println "‚ùå jpackage failed, creating launcher script instead"
            println "Error output: ${process.errorStream.text}"
            createLinuxLauncher(buildDir, sourceJar)
        }
    }
}

// Fallback method to create Linux launcher script
def createLinuxLauncher(buildDir, sourceJar) {
    def version = project.version
    def launcherScript = new File(buildDir, "pokermon-${version}.sh")
    def jarCopy = new File(buildDir, "pokermon.jar")
    
    // Copy JAR to build directory
    jarCopy.bytes = sourceJar.bytes
    
    // Create shell launcher script
    launcherScript.text = """#!/bin/bash
echo "Starting Pokermon v${version}..."
cd "\$(dirname "\$0")"
if [ -f "pokermon.jar" ]; then
    java -jar pokermon.jar "\$@"
else
    echo "Error: pokermon.jar not found in the same directory"
    exit 1
fi
"""
    
    // Make script executable
    launcherScript.setExecutable(true)
    
    println "‚úÖ Linux launcher created:"
    println "  üì¶ Launcher: ${launcherScript.absolutePath}"
    println "  üì¶ JAR: ${jarCopy.absolutePath}"
    println "  ‚ÑπÔ∏è  Run ./pokermon-${version}.sh to start Pokermon"
}

// Task to create macOS native executable using jpackage
task packagemacos {
    group = 'native'
    description = 'Package macOS native executable (.dmg) using jpackage'
    
    doLast {
        println "=== macOS Native Build with jpackage ==="
        
        // Ensure shared JAR is built first
        if (!project(':shared').tasks.getByName('fatJar').state.executed) {
            project(':shared').tasks.getByName('fatJar').execute()
        }
        
        def buildDir = new File(project.buildDir, 'distributions')
        buildDir.mkdirs()
        
        def sharedLibsDir = new File(project(':shared').buildDir, 'libs')
        def sourceJar = sharedLibsDir.listFiles()
            ?.find { it.name.endsWith('-fat.jar') }
        
        if (!sourceJar || !sourceJar.exists()) {
            throw new GradleException("Could not find fat JAR in ${sharedLibsDir}")
        }
        
        // Check if we're running on macOS and jpackage is available
        def osName = System.getProperty('os.name').toLowerCase()
        if (!osName.contains('mac')) {
            println "‚ö†Ô∏è  macOS package creation only supported on macOS, creating launcher script instead"
            createMacOSLauncher(buildDir, sourceJar)
            return
        }
        
        try {
            def jpackageCheck = "jpackage --version".execute()
            jpackageCheck.waitFor()
            if (jpackageCheck.exitValue() != 0) {
                throw new Exception("jpackage command failed")
            }
        } catch (Exception e) {
            println "‚ö†Ô∏è  jpackage not available, creating launcher script instead"
            createMacOSLauncher(buildDir, sourceJar)
            return
        }
        
        // Create native macOS package with jpackage
        def version = project.version
        def appName = "Pokermon"
        def tempDir = new File(buildDir, 'temp')
        tempDir.mkdirs()
        
        def jpackageCmd = [
            'jpackage',
            '--input', sharedLibsDir.absolutePath,
            '--main-jar', sourceJar.name,
            '--main-class', 'com.pokermon.GameLauncher',
            '--name', appName,
            '--app-version', version.toString(),
            '--dest', buildDir.absolutePath,
            '--temp', tempDir.absolutePath,
            '--type', 'dmg',
            '--vendor', 'Pokermon',
            '--description', 'Pokermon - Pure Kotlin-Native Poker Game'
        ]
        
        println "Running: ${jpackageCmd.join(' ')}"
        def process = jpackageCmd.execute()
        process.waitFor()
        
        if (process.exitValue() == 0) {
            println "‚úÖ Native macOS package created successfully!"
            def createdFiles = buildDir.listFiles()?.findAll { it.name.endsWith('.dmg') || it.name.endsWith('.app') }
            createdFiles?.each { file ->
                println "  üì¶ ${file.absolutePath}"
            }
        } else {
            println "‚ùå jpackage failed, creating launcher script instead"
            println "Error output: ${process.errorStream.text}"
            createMacOSLauncher(buildDir, sourceJar)
        }
    }
}

// Fallback method to create macOS launcher script
def createMacOSLauncher(buildDir, sourceJar) {
    def version = project.version
    def launcherScript = new File(buildDir, "pokermon-${version}.command")
    def jarCopy = new File(buildDir, "pokermon.jar")
    
    // Copy JAR to build directory
    jarCopy.bytes = sourceJar.bytes
    
    // Create macOS launcher script
    launcherScript.text = """#!/bin/bash
echo "Starting Pokermon v${version}..."
cd "\$(dirname "\$0")"
if [ -f "pokermon.jar" ]; then
    java -jar pokermon.jar "\$@"
else
    echo "Error: pokermon.jar not found in the same directory"
    exit 1
fi
"""
    
    // Make script executable
    launcherScript.setExecutable(true)
    
    println "‚úÖ macOS launcher created:"
    println "  üì¶ Launcher: ${launcherScript.absolutePath}"
    println "  üì¶ JAR: ${jarCopy.absolutePath}"
    println "  ‚ÑπÔ∏è  Double-click pokermon-${version}.command to start Pokermon"
}

// Task to create native executable for current platform
task packageNative {
    group = 'native'
    description = 'Package native executable for current platform'
    
    doLast {
        def osName = System.getProperty('os.name').toLowerCase()
        println "=== Detecting Platform: ${osName} ==="
        
        if (osName.contains('windows')) {
            println "Detected Windows platform"
        } else if (osName.contains('linux')) {
            println "Detected Linux platform"
        } else if (osName.contains('mac')) {
            println "Detected macOS platform"
        } else {
            println "Unknown platform: ${osName}, defaulting to JAR"
        }
        println "Platform-specific package created successfully"
    }
}

// Configure dependencies based on platform
def osName = System.getProperty('os.name').toLowerCase()
if (osName.contains('windows')) {
    packageNative.dependsOn packagewindows
} else if (osName.contains('linux')) {
    packageNative.dependsOn packagelinux
} else if (osName.contains('mac')) {
    packageNative.dependsOn packagemacos
} else {
    packageNative.dependsOn ':shared:fatJar'
}

// Development information task
task nativeInfo {
    group = 'help'
    description = 'Display native build information'
    
    doLast {
        println "=== Pokermon Native Build Information ==="
        println "Project: ${project.name}"
        println "Version: ${project.version}"
        println "Platform: ${System.getProperty('os.name')}"
        
        // Check jpackage availability
        def jpackageAvailable = false
        try {
            def jpackageCheck = "jpackage --version".execute()
            jpackageCheck.waitFor()
            if (jpackageCheck.exitValue() == 0) {
                jpackageAvailable = true
                def version = jpackageCheck.text.trim()
                println "jpackage: Available (${version})"
            }
        } catch (Exception e) {
            println "jpackage: Not available"
        }
        
        println ""
        println "Native Build Commands:"
        println "  ./gradlew :desktop:packageNative    - Build for current platform"
        println "  ./gradlew :desktop:packagewindows   - Build Windows executable"
        println "  ./gradlew :desktop:packagelinux     - Build Linux package" 
        println "  ./gradlew :desktop:packagemacos     - Build macOS package"
        println ""
        
        if (jpackageAvailable) {
            println "‚úÖ Native compilation available using jpackage"
            println "   Creates true platform-native executables and installers"
            println ""
            println "Output formats:"
            println "  Windows: .exe executable and optional .msi installer"
            println "  Linux:   .deb package with system integration"
            println "  macOS:   .dmg disk image with .app bundle"
        } else {
            println "‚ö†Ô∏è  jpackage not available - fallback launchers will be created"
            println "   Requires JDK 17+ for native executable creation"
            println ""
            println "Fallback formats:"
            println "  Windows: .bat launcher script + JAR"
            println "  Linux:   .sh launcher script + JAR"  
            println "  macOS:   .command launcher script + JAR"
        }
    }
}

// Ensure shared module JAR is built before packaging
packagewindows.dependsOn ':shared:fatJar'
packagelinux.dependsOn ':shared:fatJar'
packagemacos.dependsOn ':shared:fatJar'
packageNative.dependsOn ':shared:fatJar'